'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

exports.default = function (opts) {
  var options = Object.assign({
    prefix: '',
    classic: false
  }, opts);
  var prefix = options.prefix || '';
  var classic = options.classic || false;

  return function () {
    for (var _len = arguments.length, plugs = Array(_len), _key = 0; _key < _len; _key++) {
      plugs[_key] = arguments[_key];
    }

    if (plugs.length < 1) throw new Error('No module to load');

    var last = plugs[plugs.length - 1];

    // test will always true when param is array/object or non empty string
    var test = Boolean(last);

    // if test is true, check for boolean string
    if (test && /false|true|\d/.test(last)) {
      test = Boolean(JSON.parse(last));
      plugs.pop();
    }

    if (!test) return [];

    var callee = function callee(name, opts) {
      opts = opts ? [].concat(opts) : [];

      var Fn = void 0;
      if (name.indexOf('::') !== -1) {
        var _name$split = name.split('::'),
            _name$split2 = _slicedToArray(_name$split, 2),
            parent = _name$split2[0],
            child = _name$split2[1];

        Fn = require(prefix + parent)[child];
      } else {
        Fn = require(prefix + name);
      }

      if (classic) {
        return new (Function.prototype.bind.apply(Fn, [null].concat(_toConsumableArray(opts))))();
      }

      return Fn.apply(null, opts);
    };

    return plugs
    // flatten array
    .reduce(function (a, c) {
      return a.concat(c);
    }, [])
    // remove dupe, empty and boolean(test) value
    .filter(function (v, i, a) {
      return a.indexOf(v) === i && typeof v !== 'boolean' && v;
    }).map(function (p) {
      if (typeof p === 'string') {
        return callee(p);
      }

      return Object.keys(p).filter(function (x) {
        return p[x];
      }).map(function (z) {
        return p[z] === true ? callee(z) : callee(z, p[z]);
      });
    })
    // reflatten array
    .reduce(function (a, c) {
      return a.concat(c);
    }, []);
  };
};

module.exports = exports['default'];