"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.selectInferedField = exports.selectIdentifier = exports.selectTemplateName = exports.selectAllowDeletion = exports.selectAllowNewEntries = exports.selectEntrySlug = exports.selectEntryPath = exports.selectFileEntryLabel = exports.selectFolderEntryExtension = exports.selectFields = exports.selectMediaFolders = exports.selectFieldsMediaFolders = void 0;

var _escapeRegExp2 = _interopRequireDefault(require("lodash/escapeRegExp"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _immutable = require("immutable");

var _consoleError = _interopRequireDefault(require("../lib/consoleError"));

var _config = require("../actions/config");

var _collectionTypes = require("../constants/collectionTypes");

var _fieldInference = require("../constants/fieldInference");

var _formats = require("../formats/formats");

var _entries = require("./entries");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const collections = function collections() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _config.CONFIG_SUCCESS:
      {
        const configCollections = action.payload ? action.payload.get('collections') : (0, _immutable.List)();
        return configCollections.toOrderedMap().map(item => {
          const collection = item;

          if (collection.has('folder')) {
            return collection.set('type', _collectionTypes.FOLDER);
          }

          if (collection.has('files')) {
            return collection.set('type', _collectionTypes.FILES);
          }
        }) // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore
        .mapKeys((key, collection) => collection.get('name'));
      }

    default:
      return state;
  }
};

const selectors = {
  [_collectionTypes.FOLDER]: {
    entryExtension(collection) {
      return (collection.get('extension') || (0, _get2.default)(_formats.formatExtensions, collection.get('format') || 'frontmatter')).replace(/^\./, '');
    },

    fields(collection) {
      return collection.get('fields');
    },

    entryPath(collection, slug) {
      const folder = collection.get('folder').replace(/\/$/, '');
      return "".concat(folder, "/").concat(slug, ".").concat(this.entryExtension(collection));
    },

    entrySlug(collection, path) {
      var _path$split$pop;

      const folder = collection.get('folder').replace(/\/$/, '');
      const slug = (_path$split$pop = path.split(folder + '/').pop()) === null || _path$split$pop === void 0 ? void 0 : _path$split$pop.replace(new RegExp("\\.".concat((0, _escapeRegExp2.default)(this.entryExtension(collection)), "$")), '');
      return slug;
    },

    allowNewEntries(collection) {
      return collection.get('create');
    },

    allowDeletion(collection) {
      return collection.get('delete', true);
    },

    templateName(collection) {
      return collection.get('name');
    }

  },
  [_collectionTypes.FILES]: {
    fileForEntry(collection, slug) {
      const files = collection.get('files');
      return files && files.filter(f => (f === null || f === void 0 ? void 0 : f.get('name')) === slug).get(0);
    },

    fields(collection, slug) {
      const file = this.fileForEntry(collection, slug);
      return file && file.get('fields');
    },

    entryPath(collection, slug) {
      const file = this.fileForEntry(collection, slug);
      return file && file.get('file');
    },

    entrySlug(collection, path) {
      const file = collection.get('files').filter(f => (f === null || f === void 0 ? void 0 : f.get('file')) === path).get(0);
      return file && file.get('name');
    },

    entryLabel(collection, slug) {
      const path = this.entryPath(collection, slug);
      const files = collection.get('files');
      return files && files.find(f => (f === null || f === void 0 ? void 0 : f.get('file')) === path).get('label');
    },

    allowNewEntries() {
      return false;
    },

    allowDeletion(collection) {
      return collection.get('delete', false);
    },

    templateName(_collection, slug) {
      return slug;
    }

  }
};

const getFieldsMediaFolders = fields => {
  const mediaFolders = fields.reduce((acc, f) => {
    if (f.has('media_folder')) {
      acc = [...acc, f.get('media_folder')];
    }

    if (f.has('fields')) {
      var _f$get;

      const fields = (_f$get = f.get('fields')) === null || _f$get === void 0 ? void 0 : _f$get.toArray();
      acc = [...acc, ...getFieldsMediaFolders(fields)];
    }

    if (f.has('field')) {
      const field = f.get('field');
      acc = [...acc, ...getFieldsMediaFolders([field])];
    }

    return acc;
  }, []);
  return mediaFolders;
};

const selectFieldsMediaFolders = collection => {
  if (collection.has('folder')) {
    const fields = collection.get('fields').toArray();
    return getFieldsMediaFolders(fields);
  } else if (collection.has('files')) {
    var _collection$get;

    const fields = (_collection$get = collection.get('files')) === null || _collection$get === void 0 ? void 0 : _collection$get.toArray().map(f => f.get('fields').toArray());
    const flattened = [];
    return getFieldsMediaFolders(flattened.concat(...fields));
  }

  return [];
};

exports.selectFieldsMediaFolders = selectFieldsMediaFolders;

const selectMediaFolders = (state, collection, entry) => {
  var _collection$get2;

  const fieldsFolders = selectFieldsMediaFolders(collection);
  const folders = fieldsFolders.map(folder => (0, _entries.selectMediaFolder)(state.config, collection, entry, folder));

  if (collection.has('media_folder') || ((_collection$get2 = collection.get('files')) === null || _collection$get2 === void 0 ? void 0 : _collection$get2.find(file => (file === null || file === void 0 ? void 0 : file.get('name')) === (entry === null || entry === void 0 ? void 0 : entry.get('slug')) && (file === null || file === void 0 ? void 0 : file.has('media_folder'))))) {
    folders.unshift((0, _entries.selectMediaFolder)(state.config, collection, entry, undefined));
  }

  return folders;
};

exports.selectMediaFolders = selectMediaFolders;

const selectFields = (collection, slug) => selectors[collection.get('type')].fields(collection, slug);

exports.selectFields = selectFields;

const selectFolderEntryExtension = collection => selectors[_collectionTypes.FOLDER].entryExtension(collection);

exports.selectFolderEntryExtension = selectFolderEntryExtension;

const selectFileEntryLabel = (collection, slug) => selectors[_collectionTypes.FILES].entryLabel(collection, slug);

exports.selectFileEntryLabel = selectFileEntryLabel;

const selectEntryPath = (collection, slug) => selectors[collection.get('type')].entryPath(collection, slug);

exports.selectEntryPath = selectEntryPath;

const selectEntrySlug = (collection, path) => selectors[collection.get('type')].entrySlug(collection, path);

exports.selectEntrySlug = selectEntrySlug;

const selectAllowNewEntries = collection => selectors[collection.get('type')].allowNewEntries(collection);

exports.selectAllowNewEntries = selectAllowNewEntries;

const selectAllowDeletion = collection => selectors[collection.get('type')].allowDeletion(collection);

exports.selectAllowDeletion = selectAllowDeletion;

const selectTemplateName = (collection, slug) => selectors[collection.get('type')].templateName(collection, slug);

exports.selectTemplateName = selectTemplateName;

const selectIdentifier = collection => {
  const identifier = collection.get('identifier_field');
  const identifierFields = identifier ? [identifier, ..._fieldInference.IDENTIFIER_FIELDS] : _fieldInference.IDENTIFIER_FIELDS;
  const fieldNames = collection.get('fields', (0, _immutable.List)()).map(field => field === null || field === void 0 ? void 0 : field.get('name'));
  return identifierFields.find(id => fieldNames.find(name => (name === null || name === void 0 ? void 0 : name.toLowerCase().trim()) === id.toLowerCase().trim()));
};

exports.selectIdentifier = selectIdentifier;

const selectInferedField = (collection, fieldName) => {
  if (fieldName === 'title' && collection.get('identifier_field')) {
    return selectIdentifier(collection);
  }

  const inferableField = _fieldInference.INFERABLE_FIELDS[fieldName];
  const fields = collection.get('fields');
  let field; // If collection has no fields or fieldName is not defined within inferables list, return null

  if (!fields || !inferableField) return null; // Try to return a field of the specified type with one of the synonyms

  const mainTypeFields = fields.filter(f => (f === null || f === void 0 ? void 0 : f.get('widget', 'string')) === inferableField.type).map(f => f === null || f === void 0 ? void 0 : f.get('name'));
  field = mainTypeFields.filter(f => inferableField.synonyms.indexOf(f) !== -1);
  if (field && field.size > 0) return field.first(); // Try to return a field for each of the specified secondary types

  const secondaryTypeFields = fields.filter(f => inferableField.secondaryTypes.indexOf(f === null || f === void 0 ? void 0 : f.get('widget', 'string')) !== -1).map(f => f === null || f === void 0 ? void 0 : f.get('name'));
  field = secondaryTypeFields.filter(f => inferableField.synonyms.indexOf(f) !== -1);
  if (field && field.size > 0) return field.first(); // Try to return the first field of the specified type

  if (inferableField.fallbackToFirstField && mainTypeFields.size > 0) return mainTypeFields.first(); // Coundn't infer the field. Show error and return null.

  if (inferableField.showError) {
    (0, _consoleError.default)("The Field ".concat(fieldName, " is missing for the collection \u201C").concat(collection.get('name'), "\u201D"), "Netlify CMS tries to infer the entry ".concat(fieldName, " automatically, but one couldn't be found for entries of the collection \u201C").concat(collection.get('name'), "\u201D. Please check your site configuration."));
  }

  return null;
};

exports.selectInferedField = selectInferedField;
var _default = collections;
exports.default = _default;